# Лабораторная работа по дисциплине "Интеллектуальное управление робототехническими комплексами и системами"

## Задача

&ensp; В рамках данной работы необходимо выполнить задачу по объездом робота препядствий и движение к цели, вокруг которой вращаются спутники по орбитам. Роботу заранее неизвестен характер движения препдядствий.

## Информация в GITHAB

&ensp; В данном репрезитории находится отчёт + рабочий код для выполнения задания, описанного во отчёте. Код написан на языке Python.
---

## Код

&ensp; Код разбит на два основных блока: main и navigation


### Блок main

&ensp; Этот файл реализует **основной цикл управления** роботом, интегрируя данные с датчиков, одометрию и нечёткий контроллер навигации для достижения целевой точки.

#### Библиотеки 

&ensp; requests - используется для создания API запросов к роботу через подключение по WiFi. С помощью неё происходит получение данных с одометрии и сенсоров робота, а также отправка управляющих комант (уставок).

&ensp; socket - применяется для создания устойчивого соеденения с роботом по TCP/IP.

&ensp; math - применяется для математических операций (как пример - distance = math.hypot(delta_x, delta_y).

&ensp; time - для взаимодействия с временем, скажем, для запуска таймеров или задержек.

&ensp; sys - для взаимодейся с программой, скажем, для коректного завершения программы и выхода из неё.


#### Назначение

1. Установка соединения с роботом.
2. Чтение данных с датчиков и одометрии.
3. Расчет скоростей через `NavigationController`.
4. Отправка управляющих команд.
5. Обработка аварийных ситуаций и остановка.


####  Глобальные настройки

```python
ROBOT_IP = '192.168.0.1'       # IP-адрес робота
CONTROL_PORT = 80              # Порт управления
TARGET_X = 0.5                 # Целевая координата X (м)
TARGET_Y = 0.5                 # Целевая координата Y (м)
TARGET_TOLERANCE = 0.02        # Допустимая погрешность (м)
MAX_VELOCITY = 0.20            # Макс. скорость (м/с)
```

####  Описание функций

##### `read_proximity_sensors()`
**Что делает**:  
Читает данные с массива из 9 инфракрасных датчиков расстояния робота через HTTP API.  
**Как работает**:  
1. Отправляет GET-запрос на `http://{ROBOT_IP}/data/distancesensorarray`.  
2. Проверяет код ответа (должен быть 200).  
3. Преобразует ответ в список из 9 значений.  
4. Фильтрует данные, возвращая 7 ключевых сенсоров:
   - Левые (`left_1`, `left_2`), передний (`front`), правые (`right_1`, `right_2`), задние (`rear_left`, `rear_right`).  
5. При ошибках выводит сообщение в консоль и возвращает `None`.
   
##### `CONNECT()`
**Что делает**:  
Устанавливает TCP-соединение с роботом для управления.  
**Как работает**:  
1. Создает сокет (`AF_INET` для IPv4, `SOCK_STREAM` для TCP).  
2. Подключается к `ROBOT_IP` на порт `CONTROL_PORT`.  
3. При успехе возвращает объект соединения.  
4. При ошибках (например, недоступен порт) выводит сообщение и возвращает `None`.

##### `fetch_odometry()`
**Что делает**:  
Получает текущие координаты и ориентацию робота через одометрию.  
**Как работает**:  
1. Отправляет GET-запрос на `http://{ROBOT_IP}/data/odometry`.  
2. Проверяет, что ответ содержит 7 значений (X, Y, угол и т.д.).  
3. Возвращает сырые данные в виде списка.  
4. При ошибках выводит сообщение и возвращает `None`.

##### `set_movement_velocity(vx, vy, omega)`
**Что делает**:  
Отправляет команды движения роботу в формате [vx, vy, omega].  
**Как работает**:  
1. Формирует POST-запрос к `http://{ROBOT_IP}/data/omnidrive`.  
2. Тело запроса – JSON-массив `[vx, vy, omega]`.  
3. Логирует отправленные скорости и ответ сервера.  
4. При ошибках (например, разрыв связи) выводит сообщение.

##### `calculate_position_offset(current_x, current_y)`
**Что делает**:  
Вычисляет отклонение робота от целевой точки `(TARGET_X, TARGET_Y)`.  
**Как работает**:  
1. Считает разницу:  
   - `delta_x = TARGET_X - current_x`  
   - `delta_y = TARGET_Y - current_y`  
2. Возвращает кортеж `(delta_x, delta_y)`.  
**Примечание**: Используется для определения направления движения.

##### `stop()`
**Что делает**:  
Немедленно останавливает робота.  
**Как работает**:  
Вызывает `set_movement_velocity(0, 0, 0)`, обнуляя все скорости.


##### `main_control_loop()`
**Что делает**:  
Главный цикл управления роботом.  
**Как работает**:  
1. **Инициализация**:  
   - Создает экземпляр `NavigationController`.  
   - Устанавливает соединение (`CONNECT()`).  

2. **Калибровка**:  
   - Получает начальные координаты (`odom_init`).  
   - Рассчитывает относительные координаты (`base_x`, `base_y`).  

3. **Цикл управления**:  
   - **Шаг 1**: Чтение текущих данных (`fetch_odometry()`).  
   - **Шаг 2**: Расчет отклонения от цели (`calculate_position_offset()`).  
   - **Шаг 3**: Чтение датчиков (`read_proximity_sensors()`).  
   - **Шаг 4**: Вычисление скоростей через `NavigationController.calculate_velocity()`.  
   - **Шаг 5**: Проверка достижения цели (`math.hypot(delta_x, delta_y) <= TARGET_TOLERANCE`).  
   - **Шаг 6**: Ограничение скоростей (`MAX_VELOCITY`) и отправка команд.  
   - **Шаг 7**: Пауза 50 мс (`time.sleep(0.05`).  

--- 

### Блок navigation

#### Библиотеки

&ensp; numpy - применяется для работы с массивами и установки диапозонов фазификации

&ensp; skfuzzy - применяется для реализации нечёткой логики (фазификации, дефазификации)

&ensp; skfuzzy.control - применятся для создания баз правил

#### `NavigationController.__init__(self)`
**Назначение**: Инициализирует контроллер, создаёт входные/выходные переменные и настраивает систему нечёткой логики.  
**Как работает**:  
- Задаёт диапазоны для входных (`position_x`, `position_y`, датчики) и выходных (`velocity_x`, `velocity_y`) переменных.  
- Вызывает методы для настройки функций принадлежности и создания правил.


#### `_init_sensors(self, universe)`
**Назначение**: Создаёт антецеденты (входные переменные) для данных с датчиков расстояния.  
**Как работает**:  
- Инициализирует 7 датчиков (например, `sensor_left_front`, `sensor_front`).  
- Для каждого задаётся диапазон значений `universe` (0–0.41 м).


#### `_configure_membership(self)`
**Назначение**: Определяет функции принадлежности для всех переменных.  
**Как работает**:  
- Для **позиций** (`position_x`, `position_y`):  
  - Трапециевидные/треугольные функции: `far_back`, `center`, `far_front` и т.д.  
- Для **датчиков**:  
  - `close` (опасная зона) и `far` (безопасная зона).  
- Для **скоростей** (`velocity_x`, `velocity_y`):  
  - Трапециевидные функции: `*_fast`, `*_med`, `*_slow`, `stop`.


#### `_configure_velocity(self, var, neg_dir, pos_dir)`
**Назначение**: Настраивает функции принадлежности для выходных скоростей.  
**Как работает**:  
- Для переданной переменной (`var`):  
  - Создаёт 3 зоны для отрицательного (`neg_dir`), 3 зоны для положительного (`pos_dir`) направления и зону `stop`.


#### `_create_rules(self)`
**Назначение**: Создаёт правила для движения к цели.  
**Как работает**:  
- Для `position_x` и `position_y` задаются условия типа:  
  - Если `position_x = far_back` → `velocity_x = backward_fast`.  
  - Если `position_y = far_left` → `velocity_y = left_fast`.



#### `_create_obstacle_rules(self)`
**Назначение**: Генерирует правила для объезда препятствий.  
**Как работает**:  
- Примеры:  
  - Если `sensor_left_front` и `sensor_left_rear` близко → движение вправо.  
  - Если `sensor_front` близко → движение назад.


#### `_create_dynamic_rules(self)`
**Назначение**: Добавляет правила для сложных сценариев (близость цели + препятствия).  
**Как работает**:  
- Примеры:  
  - Если цель близко (`near_front`), но есть препятствие слева → медленное движение вперёд и вправо.  
  - Если робот смещён вбок (`far_left`), но препятствий нет → движение вперёд без коррекции.


#### `_init_control_systems(self)`
**Назначение**: Инициализирует системы нечёткого управления.  
**Как работает**:  
- Создаёт две независимые системы:  
  - `goal_system` – для движения к цели.  
  - `obstacle_system` – для объезда препятствий.



#### `calculate_velocity(self, dx, dy, *sensors)`
**Назначение**: Главная функция для расчёта скоростей.  
**Как работает**:  
- Проверяет наличие препятствий через `_has_obstacles()`.  
- Выбирает стратегию: `_avoid_obstacles()` или `_move_to_target()`.  
- Корректирует скорости через `_adjust_speeds()`.



#### `_has_obstacles(self, sensors)`
**Назначение**: Проверяет, есть ли препятствия вблизи.  
**Как работает**:  
- Возвращает `True`, если хотя бы один датчик показывает расстояние меньше `OBSTACLE_THRESHOLD` (0.20 м).



#### `_avoid_obstacles(self, dy, sensor_data)`
**Назначение**: Рассчитывает скорости для объезда препятствий.  
**Как работает**:  
- Передаёт данные датчиков в `obstacle_system`.  
- Вычисляет скорости через `obstacle_sim.compute()`.



#### `_move_to_target(self, dx, dy)`
**Назначение**: Рассчитывает скорости для движения к цели.  
**Как работает**:  
- Передаёт отклонения `dx`, `dy` в `goal_system`.  
- Вычисляет скорости через `goal_sim.compute()`.



#### `_adjust_speeds(self, dx, dy, vx, vy)`
**Назначение**: Корректирует скорости для плавного движения.  
**Как работает**:  
- Определяет главную ось (X или Y) по максимальному отклонению.  
- Масштабирует скорость второстепенной оси.  
- Ограничивает скорости до ±0.3 м/с.


## Заключение

&ensp; Данное описание позволяет кратко ознакомиться с содержимым проекта и тем самым получить представление о структуре программы.
